# Paper Details
- Title
  - RegLess: Just-in-Time Operand Staging for GPUs
- Conference
  - MICRO
- Year 
  - 2017
# Summary
## Abstract
- Register Files (RFs) are large and power-hungry on GPUs
  - Prior work has kept the large, high-bandwidth structure
  - Reducing the size can lead to spills and fills
- Replace the RF with an operand staging unit
  - Slice computation graphs and allocate operand storage at runtim
  - Most values have a short life (do not need to persist past regions)
  - Store longer-living operands in global memory
    - Must manage this more carefully to avoid stalls
- RegLess
  - Compiler annotations to anticipate operand usage
  - 25% less RF size
  - 75% less energy
    - 11% less GPU energy
  - No perf Loss
## Introduction
- Trend towards energy efficiency in GPUs
  - Datacenters and mobile 
- Stalls are hidden by context switches
  - Fast because all state exists in  large register files
- Prior work
  - Small HW/SW managed cache to avoid accesses
  - Dynamically reusing registers (RF virtualization)
  - Reuse unused RF as L1/scratchpad
- RegLess
  - Anticipates when registers will be used
    - Single-region registers can be reused
    - Multi-region registers can be evicted
      - Fetch from memory
    - Hardware resource manager
      - Use annotations to anticipate which registers to fetch
      - Controls which warps are eligible to issue
    - Region partitioning
      - Maximize registers interior to one region
      - Avoids spills/fills
- Contributions
  - Replace RF with operand staging unit
  - Compiler techniques to maximize registers interior to a region
  - Managmeent of operand staging unit to maximize performance
  - Power + Area analysis
  - Reduction of register capacity by 75%
## RF Replacement Challenges
- A smaller RF can not hold all live registers
  - Management must be precise
  - How much to space to allocate each warp?
  - Limited memory bandwidth
    - Spill/Fills
  - Allowing cross-region registers to fit in L1
- Capacity Allocation
  - Not every warp can have all live registers present
    - However, not every register is accessed by every warp all the time
  - Spills/Fills don't work
    - Backed by main memory! Not the RF!
    - Only schedule warps that have been allocated space
  - Allocations for running warps
    - Compiler annotations
      - Divide kernel into atomic regions
      - Activates warps when region is allocated
- Memory Side Bandwidth
  - Once access can be made through the L1$ per cycles
    - Must avoid this!
  - Define regions to minimize the number of registers that must go through the L1$
    - Areas with fewest number of live registers
  - Early loading into staging unit
    - Activate region from previously active warp (locality)
    - Preload registers before issuing an instruction
- L1 Cache Capacity
  - Combined L1 and Operand Staging Unit are still smaller than the regiser working set of some kernels
    - Compression based on value similarity
## Design Overview
- Compile time
  - Kernel is divided into regions of instructions
  - Anotates the inputs and outputs of these regions
- Run time
  - Registers are stored in the operand staging unit
  - Actively manage the operand staging unit
  - Capacity manager uses free capacity to preload registers
## Compiler Code Generation
- Region Creation
  - Natural 'seams' in the application when values are computed
  - Break apart global load and first use
    - Taking up space in the operand staging unit
  - Regions do not span basic block boundaries
    - Oblivious to control flow
- Region Creation Algorithm
  - Creates a CFG with regions equal to BBs
  - Iterates through each region
    - Does it meet constraints?
      - Max registers of operand staging unit, global load+first use, etc.
      - No? Split! (may happen multiple times)
        - First PC where region becomes invalid
- Register Lifetime
  - Erase annotation for last use of an interior register
  - Evict annotation for input/output registers
  - Managing L1
    - Die when pre-loaded for the last time
    - CF ends their life
- Control Flow and Register Liveness
  - Soft-definitiion (may not kill an entire register)
    - Must be used in other path
  - Must invalidate in the post-dominator of both definitions
  - Pre-load soft definitions to preserve registers
## Hardware Design
- Per scheduler
  - Capacity managers
    - Allocate OSU resources
    - State machines for supervised warps
    - Warp stack for inactive warps
    - Countrers tracking preloads and evictions
    - What about long-latency last instructions?
     - Free all registers other than pending ones (e.g. for loads)
  - Operand Staging Units
    - 8 independent banks
    - Free, clean, and dirty list
    - Preloads and allocations
      - Allocation occurs through preload or write to interior registers
      - Preloads are passed from the CMs for each bank in parallel
      - Register is either in clean/dirty list (otherwise send to compressor/L1$)
  - Evictions
    - Registers marked for inval. are added to the free list
      - Mark after last write using that register
    - Output registers put in the clean/dirty list
  - Register -> Memory Mapping
    - cudaMalloc()
    - Registers are laid out sequentially
  - Compressor Units
    - Bitmask of compressed registers
    - Can store 15 ompressed registers in a single cache line
      - Extra cycle of latency for non-compressed preloads
      - +2 for compressed ones
  - Metadata Encoding
    - Added to instruction stream by the compiler
    - Regions start with flag instruction
      - Bank usage + up to 3 preloads and cache evictions
        - More as necessary
    - Every 9 instructions, one metadata one to mark last use of registers
  - Arbiter to direct reads to the correct operand staging unit
## Evaluation
- Methodology
  - GPGPU-Sim w/ GTX 980 configuration
    - PTXPlus
    - Implemented baseline RF design and RegLess in Verilog
  - Compared against
    - Register File Virtualization (RFV)
    - Register File Caching (RFH)
- Area and Power
  - Best power/area at 128 register, but negligible perf. hit at 512
-  Energy Savings
  - 75.3% reduction
  - 11% overall
- Performance
  - Most benchmarks see no performance change
  - Some benchmarks have complex control flow
    - Can't invalidate until last use
  - Others have registers live across global loads
- Register Preload Location, L1 Bandwidth
  - Rarely go to main memory
  - Compressors help when register working set grows
    - Still, some can't be compressed
- Region sizes
  - Most register lifetimes are within a region
  - Region size typically limits control flow
    - Compute benchmarks typically have the largest regions
## Related work
- Caching register space in memory
  - Too naive (requires more active management)
- RFC + RFV
- Resource-aware scheduling
- Divergence aware scheduling
- Value compression/scalarization
## Conclusion
- RFs are large structures that consume a lot of power
- Replace register file with smaller, actively managed staging unit
  - Compiler help
- Reduce register access energy by 75%, and total GPU energy by 11%
